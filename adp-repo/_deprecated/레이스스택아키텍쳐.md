ForzaETH 레이스 스택의 소프트웨어 아키텍처는 **상업용 하드웨어 기반 자율 주행 레이싱(CotS)** 이라는 맥락에서, **접근성이 높은** F1TENTH 플랫폼의 제한된 컴퓨팅 자원 내에서도 **고성능의 무제한 Head-to-Head 레이싱**을 실현하기 위해 설계된 **모듈화된 계층적 시스템**임.

**See-Think-Act 패러다임**을 따르며, **인식(Perception) - 계획(Planning) - 제어(Control)**라는 체계적인 흐름으로 구현됨. 이러한 구조는 각 모듈 간의 상호 작용과 연결성을 강조하며, 상위 모듈의 성능이 하위 모듈에 연쇄적인 영향(knock-on effects)을 미친다는 점을 중요하게 다룸.

===
 ForzaETH 레이스 스택의 주요 소프트웨어 아키텍처 구성 요소에 대한 논의

### 1. 설계 철학 및 구현 환경

*   **모듈화 및 유연성:** 스택은 모듈성(modularity)과 운영 용이성을 염두에 두고 설계되었으며, 트랙 마찰 및 레이아웃과 같은 다양한 환경 조건에 대한 맞춤화 및 적응성을 허용.
*   **ROS 기반 구현:** 자율 주행 모듈은 **ROS1 Noetic**을 사용하여 구현되었으며, **Python**과 **C++** 언어가 사용되었음.
    *   **언어 선택 원칙:** **C++**은 대기 시간이 중요한(latency critical) 노드에 필요한 속도와 성능을 위해 사용되었고, **Python**은 개발의 단순성과 효율성을 위해 활용됨.
*   **통합 및 오픈 소스:** ROS 생태계를 활용하여 많은 오픈 소스 로봇 공학 도구, 알고리즘 및 센서 드라이버를 이 스택에 활용할 수 있었습니다. 전체 스택은 재현성(reproducibility)을 위해 오픈 소스로 공개.
*   **온보드 컴퓨팅(Fully Onboard Computing):** F1TENTH의 제약 조건에 따라, 모든 계산은 차량에 완전히 탑재된 컴퓨터(Intel NUC 10 등 CotS 하드웨어)에서 수행됨.
*   **시뮬레이터 전환:** 아키텍처는 물리적 로봇과 최소한의 경량 ROS 시뮬레이션 환경 간에 **원활하게 전환**되도록 인터페이스가 동일하게 설계됨.

### 2. 핵심 자율 주행 모듈 (Perception-Planning-Control)

#### A. Perception (인식)

인식 모듈은 차량의 상태를 정확하게 파악하고 환경 내 동적 및 정적 장애물을 감지하는 역할을 함. 
상태 추정은 하위 모듈에 영향을 미치는 **기초 요소**로 강조됩니다.

1.  **State Estimation (상태 추정):**
    *   **우리는 시뮬레이터를 다룰 것이므로 시뮬레이터가 작동할 때, 차량의 감각 및 위치 추정 부분은 시뮬레이터의 출력으로 대체되고, 인지와 계획 및 제어와 같은 상위 레벨의 결정 모듈은 계속해서 실행됨.**
    *   **역할:** 위치 추정(localization)과 속도 추정(velocity estimation)으로 나뉘며, LiDAR, IMU, 휠 주행 기록계(ERPM 데이터) 등 여러 센서 입력을 융합하고 필터링합니다.
    *   **1) 속도 추정:** **확장 칼만 필터(EKF)**를 사용하여 휠 슬립 상황에서 종방향 및 횡방향 속도를 추정합니다.
    *   **2) 위치 추정(Localization):** 상호 배타적인 두 가지 알고리즘을 지원하여 다양한 트랙 조건에 유연하게 대응합니다.
        *   **Cartographer (SLAM 기반):** 고품질 주행 기록계 입력 데이터가 제공될 때 가장 정확하고 부드러운 자세 추정값을 제공합니다.
        *   **SynPF (MCL 기반 입자 필터):** 주행 기록계의 품질이 낮을 때(예: 휠 슬립이 심할 때) 높은 **강인성(robustness)**을 제공하며, 계산 비용이 Cartographer에 비해 낮습니다.

2.  **Opponent Estimation (상대방 추정):**
    *   **역할:** Head-to-Head 레이스에서 상대방 레이스카를 감지, 분류 및 추적합니다.
    *   **감지:** **Adaptive Breakpoint 메서드**를 사용하여 LiDAR 데이터를 클러스터링하고, 트랙 경계 필터링 및 크기 필터링을 통해 오탐지율(FDR)을 최소화하고 진양성률(TPR)을 높입니다.
    *   **추적:** **EKF**를 활용하여 상대방의 위치 및 속도를 Frenet 좌표계로 공식화하여 측정 잡음에 강인하게 안정적인 추정값을 제공하며, **시야(LoS)가 없을 때**에도 추정값을 지속적으로 제공합니다.

#### B. Planning (계획)

계획 모듈은 **글로벌 플래너**와 **로컬 플래너**로 나뉘며, 환경 변화에 동적으로 적응하여 효율적인 궤적을 계획함.

1.  **Global Planner (글로벌 플래너):**
    *   **역할:** 레이스 전에 **오프라인**에서 트랙 맵을 기반으로 **최소 곡률 궤적 최적화**를 통해 최적화된 레이싱 라인을 계산합니다.
    *   **속도 프로파일:** 전역 경로에 대한 속도 프로파일도 생성하며, 트랙 마찰 변화에 대응하기 위해 **베이지안 최적화(BO)** 또는 수동 조정을 통해 경로 속도를 조정하는 **섹터 스케일러**를 사용합니다.

2.  **State Machine (상태 머신):**
    *   전역 경로 추종(**GBFree**), 상대방 추종(**Trailing**), 또는 **Overtake(추월)** 중 어떤 고수준 행동을 수행할지 결정합니다. 안전에 문제가 생길 경우(poor state estimation), **Reactive** 상태로 전환되어 FTG(Follow The Gap) 컨트롤러를 사용합니다.

3.  **Local Planner (로컬 플래너):**
    *   **역할:** 상대방 추정 정보에 기반하여 **추월 기동**을 위한 궤적을 실시간으로 동적으로 계산합니다.
    *   **궤적 생성:** 상대방 주변의 특정 지점들($p_{\text{spline}}$)을 선택하고 **3차 스플라인**을 피팅하여 원래 레이싱 라인으로 재연결되는 회피 궤적을 생성합니다. 이 궤적은 트랙 경계 내에 안전하게 머무르는지 확인하는 공간적 임계값 검사를 거칩니다.

#### C. Control (제어)

제어 모듈은 계획 모듈에서 결정된 웨이포인트를 정확하게 따르며, 횡방향 편차를 낮게 유지하고 원하는 속도를 정밀하게 추적하는 역할을 함.

1.  **Lateral Control (횡방향 제어):**
    *   **MAP (Model- and Acceleration-based Pursuit) 컨트롤러**를 채택했습니다.
    *   **특징:** 순수 기하학적 컨트롤러(Pure Pursuit)를 능가하기 위해 차량의 **정상 상태 코너링 동작 모델**과 **타이어 슬립**을 통합합니다. 필요한 구심 가속도($a_c$)를 계산하고, 미리 계산된 **룩업 테이블**을 사용하여 해당 조향각을 검색합니다.

2.  **Longitudinal Controller (종방향 제어):**
    *   **Nominal Velocity Controller:** GBFree 또는 Overtake 상태에서 사용되며, 계획된 궤적의 속도 프로파일을 따릅니다. 작동 및 계산 지연을 보정하기 위해 미리 정해진 **룩어헤드 시간**을 사용하여 참조 속도를 계산합니다.
    *   **Trailing Velocity Controller:** Trailing 상태일 때 사용되며, **PD 컨트롤러**와 상대방 속도 피드포워드 항을 사용하여 상대방 차량과의 **일정한 거리(gap)**를 유지하도록 속도를 조정합니다. 모듈로 연산자를 사용하여 랩을 넘어 순환하는 s 좌표의 특성을 처리합니다.
